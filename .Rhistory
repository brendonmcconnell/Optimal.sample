}
### Best set of parameters found
V.t <- sapply(optim.cost.t, `[[`, "par")
mc.output.t$cost <- sapply(optim.cost.t, `[[`, "value")
mc.output.t$m0 <- V.t[1,]
if (optimal == 0) {
mc.output.t$m1 <- V.t[2,]
mc.output.t$k1 <- V.t[3,]
} else if (optimal == 1){
mc.output.t$m1 <- V.t[1,]
mc.output.t$k1 <- V.t[2,]
} else if (optimal == 2){
mc.output.t$m1 <- V.t[2,]
mc.output.t$k1 <- c(NA)
}
### Value of K0 using the best parameters found in the optimization process
if (optimal != 2){
mc.output.t$k0 <-   ((mc.output.t$kappa*((1+((mc.output.t$m0-1)*rho))/(mc.output.t$m0))) /
((delta^2) - (mc.output.t$kappa*((1+((mc.output.t$m1-1)*rho))/(mc.output.t$m1*mc.output.t$k1)))))
} else if (optimal == 2) {
mc.output.t$k0 =    ((mc.output.t$kappa/(delta^2)) * (((1+((mc.output.t$m0-1)*rho))/(mc.output.t$m0)) + ((1+((mc.output.t$m1-1)*rho))/(mc.output.t$m1))))
mc.output.t$k1 <-   mc.output.t$k0
}
### Sort variables
mc.output.t <- mc.output.t[, c("iter.mc", "scenario", "delta", "sigma", "rho", "alpha", "beta", "m0.ic", "m1.ic", "k0.ic", "k1.ic", "kappa", 'v0', "v1", "f0", "f1", 'k0', "k1", 'm0', "m1", 'cost', "K")]
### Kt
mc.output.t$Kt <- mc.output.t$k0 + mc.output.t$k1
### Test K and Kt for exact equality
abs.dif.K <- abs(mc.output.t$'K' - mc.output.t$"Kt")
mc.output.t$same = ifelse((abs.dif.K< 0.01), "TRUE", "FALSE")
### Combine Outputs.t data frames,
min.costs<- as.data.frame(rbind(mc.output.t, min.costs))
### Condition to break the iterations
brk = sum (ifelse (mc.output.t$"same"== "TRUE",1,0))
if (brk==length(scenario)) {
break
}
### Delete data from iteration
rm ("mc.kappa", "optim.cost.t", "V.t" )
}
### Keep the best parameters found in the optimization process
min.costs$K=min.costs$Kt
results <- (min.costs[1:nrow(mc.output.t), c("scenario", "delta", "sigma", "rho", "k0.ic", "k1.ic", "m0.ic", "m1.ic", 'v0', "v1", "f0", "f1", 'k0', "k1", 'm0', "m1", 'cost', "K")])
### Delete data frames of initial conditions
rm ("mc.output.t", "mc.kappa", "V.t", "optim.cost.t")
### Transposing objects
options(scipen=24)
minimum.costs <- ((t(results)))
return (minimum.costs)
}
# Power function NO ANCOVA (1)------------------------------------------------------------
#'
#' @description This function estimates the power of the RCT using normal distribution.
#'
#' @param x  Vector. Parameters to be optimized.
#' @param delta Vector. Size of the effect on the outcome variable (effect size measured in same units as the outcome variable).
#' @param sigma Vector. Standard deviation of the outcome variable.
#' @param rho Vector. Intra-cluster correlation.
#' @param C Vector. Maximum level of costs of implementing the RCT. It includes data collection costs (baseline and endline) and the costs of implementing the intervention under study.
#' @param t.a  Cumulative distribution function of the normal distribution.
#' @param v0 Vector. Variable costs per unit in the control clusters. It includes the cost of data collection (baseline and endline) and the cost of implementing the intervention under study.
#' @param v1 Vector. Variable costs per unit in the treatment clusters. It includes the cost of data collection (baseline and endline) and the cost of implementing the intervention under study.
#' @param f0 Vector. Fixed costs per control cluster. It includes the total fixed cost: baseline and endline.
#' @param f1 Vector. Fixed costs per treatment cluster. It includes the total fixed cost: baseline and endline.
#' @param optimal Indicates whether the sample design should constrain the number of units per treatment and control clusters to be the same ("1") or whether the sample design should constrain the treatment and control clusters to be the same "2" or whether the solution should be fully unconstrained ("0").
#'
#' @return Vector. Returns (power) the value of the power of the RCT using normal distribution.
#'
#'
#' @export
power.func.nA  <- function(x,
delta,
sigma,
rho,
C,
t.a,
v0,
v1,
f0,
f1,
optimal) {
if (optimal != 2 ){
if (optimal == 0 ) {
m0 <- x[1]
m1 <- x[2]
k1 <- x[3]
} else if (optimal == 1 ) {
m0 <- x[1]
m1 <- m0
k1 <- x[2]
}
k0 <- ((C - (k1 * (f1 + (v1*m1))))/(f0 + (v0*m0)))
if (k0 >= 1) {
power <- - (pnorm(((delta/(sqrt(sigma^2*(((1+((m0-1)*rho))/(m0*((C - (k1*(f1 + (v1*m1))))/(f0 + (v0*m0)))))
+ ((1+((m1-1)*rho))/(m1*k1))))))- t.a), lower.tail=FALSE))
return(power)
} else  {
return(0)
}
} else if (optimal == 2) {
m0 <- x[1]
m1 <- x[2]
k0 <- (C /((f0+f1) + (v0*m0) + (v1*m1)))
if (k0 >= 1) {
power = - (pnorm((((delta*sqrt(C /((f0+f1) + (v0*m0) + (v1*m1)))) /
(sqrt(sigma^2*((1+((m0-1)*rho))/(m0) + ((1+((m1-1)*rho))/(m1))))))
- t.a), lower.tail=FALSE))
return(power)
} else {
return(0)
}
}
}
# Power function NO ANCOVA (2)------------------------------------------------------------
#'
#' @description This function estimates the power of the RCT using t-distribution.
#'
#' @param x  Vector. Parameters to be optimized.
#' @param delta Vector. Size of the effect on the outcome variable (effect size measured in same units as the outcome variable).
#' @param sigma Vector. Standard deviation of the outcome variable.
#' @param rho Vector. Intra-cluster correlation.
#' @param C Vector. Maximum level of costs of implementing the RCT. It includes data collection costs (baseline and endline) and the costs of implementing the intervention under study.
#' @param t.a  Cumulative distribution function of the normal distribution.
#' @param df The degrees of freedom (K-q) to test the null hypothesis of null effect.
#' @param v0 Vector. Variable costs per unit in the control clusters. It includes the cost of data collection (baseline and endline) and the cost of implementing the intervention under study.
#' @param v1 Vector. Variable costs per unit in the treatment clusters. It includes the cost of data collection (baseline and endline) and the cost of implementing the intervention under study.
#' @param f0 Vector. Fixed costs per control cluster. It includes the total fixed cost: baseline and endline.
#' @param f1 Vector. Fixed costs per treatment cluster. It includes the total fixed cost: baseline and endline.
#' @param optimal Indicates whether the sample design should constrain the number of units per treatment and control clusters to be the same ("1") or whether the sample design should constrain the treatment and control clusters to be the same "2" or whether the solution should be fully unconstrained ("0").
#'
#' @return Vector. Returns (power) the value of the power of the RCT using t-distribution.
#'
#'
#' @export
power.func.t.nA  <- function(x,
delta,
sigma,
rho,
C,
t.a,
df,
v0,
v1,
f0,
f1,
optimal) {
if (optimal != 2 ){
if (optimal == 0 ) {
m0 <- x[1]
m1 <- x[2]
k1 <- x[3]
} else if (optimal == 1 ) {
m0 <- x[1]
m1 <- m0
k1 <- x[2]
}
k0 <- ((C - (k1 * (f1 + (v1*m1))))/(f0 + (v0*m0)))
if (k0 >= 1) {
power <-  - (1 - pt(((delta / (sqrt((sigma^2) * (((1+((m0-1)*rho)) /
(m0 * ((C - (k1*(f1+(v1*m1)))) / (f0+(v0*m0))))) +
((1+((m1-1)*rho)) / (m1*k1)))))) - t.a), df, lower.tail =FALSE))
return(power)
} else  {
return(0)
}
} else if (optimal == 2) {
m0 <- x[1]
m1 <- x[2]
k0 <- (C /((f0 + (v0*m0)) + (f1 + (v1*m1))))
if (k0 >= 1) {
power = - (1 - pt(((((delta) * (sqrt(C/((f0 +f1) + (v0*m0) + (v1*m1))))) /
(sqrt((sigma^2)*(((1+((m0-1)*rho)) / (m0)) +
((1+((m1-1)*rho)) / (m1)))))) - t.a), df, lower.tail = FALSE))
return(power)
} else {
return(0)
}
}
}
# Power maximization NO ANCOVA ------------------------------------------------------------
#'
#' @description Power maximizing sample designs for cluster Randomized Control Trials with a baseline and an endline measure subject to a costs constraint.
#'
#' @param delta Vector. Size of the effect on the outcome variable (effect size measured in same units as the outcome variable).
#' @param sigma Vector. Standard deviation of the outcome variable.
#' @param rho Vector. Intra-cluster correlation.
#' @param alpha Vector. Significance level for the null hypothesis of no effect.
#' @param C Vector. Maximum level of costs of implementing the RCT. It includes data collection costs (baseline and endline) and the costs of implementing the intervention under study.
#' @param q Where (K - q) are the degrees of freedom to test the null hypothesis of null effect. Default is 1.
#' @param v0 Vector. Variable costs per unit in the control clusters. It includes the cost of data collection (baseline and endline) and the cost of implementing the intervention under study.
#' @param v1 Vector. Variable costs per unit in the treatment clusters. It includes the cost of data collection (baseline and endline) and the cost of implementing the intervention under study.
#' @param f0 Vector. Fixed costs per control cluster. It includes the total fixed cost: baseline and endline.
#' @param f1 Vector. Fixed costs per treatment cluster. It includes the total fixed cost: baseline and endline.
#' @param optimal Indicates whether the sample design should constrain the number of units per treatment and control clusters to be the same ("1") or whether the sample design should constrain the treatment and control clusters to be the same "2" or whether the solution should be fully unconstrained ("0")
#' @param initial.cond  Vector. Initial values of the number of sample units per cluster (m0,m1) and the number of clusters (k0,k1) - keep the order- that the optimization routine will use.
#' @param lb Vector. Minimum possible value for the optimal number of clusters and optimal number of units.
#' @param ub Vector. Maximum possible value for the optimal number of clusters and optimal number of units.
#' @param temp Numeric. Temperature parameter for the GenSA optimization function. Default is NULL, in which case, the default value in GenSA function will be used.
#'
#' @return Returns a matrix of size (19 x number of Scenarios). For each scenario the matrix provide the following components: \describe{
#'
#' \item{scenario}{This is a vector of the number of the scenario displayed.}
#'
#' \item{delta}{This is a vector of the size of the effect on the outcome variable.}
#'
#' \item{sigma}{This is a vector of the standard deviation of the outcome variable.}
#'
#' \item{rho}{This is a vector of the intra-cluster correlation.}
#'
#' \item{k0.ic}{This is a vector of the number of control clusters used as initial condition of the GenSA optimization function.}
#'
#' \item{k1.ic}{This is a vector of the number of treatment clusters used as initial condition of the GenSA optimization function.}
#'
#' \item{m0.ic}{This is a vector of the number of sample units per control cluster used as initial condition of the GenSA optimization function.}
#'
#' \item{m1.ic}{This is a vector of the number of sample units per treatment cluster used as initial condition of the GenSA optimization function.}
#'
#' \item{C}{This is a vector of the maximum level of total costs of implementing the RCT. It includes data collection costs (baseline and endline) and the costs of implementing the intervention under study.}
#'
#' \item{v0}{This is a vector of the variable cost per control unit.}
#'
#' \item{v1}{This is a vector of the variable costs per treatment unit.}
#'
#' \item{f0}{This is a vector of the fixed costs per control cluster.}
#'
#' \item{f1}{This is a vector of the fixed costs per treatment cluster.}
#'
#' \item{k0}{This is a vector of the optimum number of control clusters that maximize power.}
#'
#' \item{k1}{This is a vector of the optimum number of treatment clusters that maximize power.}
#'
#' \item{m0}{This is a vector of the optimum number of sample units per control cluster that maximize power.}
#'
#' \item{m1}{This is a vector of the optimum number of sample units per treatment cluster that maximize power.}
#'
#' \item{power}{This is the vector of the power of the RCT with the optimum number of clusters and units provided by this function.}
#'
#' \item{K}{This is the vector of the optimum total number of clusters.}
#'}
#'
#'
#' @export
maxpower.nA <-  function(delta,
sigma,
rho,
alpha,
C,
q,
v0,
v1,
f0,
f1,
optimal,
initial.cond,
lb,
ub,
temp){
### additional initial values -  normal distribution
t.a= qnorm(1-(alpha/2))
### Number of scenarios
scenario <- c(1:max(length(delta), length(sigma), length(rho), length(alpha),
length(v0), length(v1), length(f0), length(f1), length(C)))
### Generate variable with the number of iteration
### iter=0 is iteration using the normal distribution
iter.pm <- c(0)
### Output file
K <- c(NA)
pm.output <- as.data.frame(cbind(iter.pm, scenario, delta, sigma, rho, alpha, C, v0, v1, f0, f1, K, t.a))
pm.output <- as.data.frame(merge(initial.cond,pm.output, by="scenario"))
### Parameters boundaries
lower <- lb
upper <- ub
### Temperature
if(is.null(temp))  {
temp <- 5230      ### Default value in GenSA function.
}else{
temp <= temp
}
### Definition of parameters according to the initial conditions
if (optimal == 0) {
m0 <- initial.cond[,'m0.ic']
m1 <- initial.cond[,'m1.ic']
k1 <- initial.cond[,'k1.ic']
params <- cbind(m0, m1, k1)
}  else if (optimal == 1){
m0 <- initial.cond[,'m0.ic']
k1 <- initial.cond[,'k1.ic']
params <- cbind(m0, k1)
} else if (optimal == 2) {
m0 <- initial.cond[,'m0.ic']
m1 <- initial.cond[,'m1.ic']
params <- cbind(m0, m1)
}
### Maximization of power
optim.power<- vector("list", nrow(pm.output))
for (i in 1:nrow(pm.output)) {
optim.power[[i]] <- GenSA(par = params[i,], fn=power.func.nA, lower=lower, upper=upper, v0=pm.output[i,'v0'], v1=pm.output[i,'v1'],
f0=pm.output[i,'f0'], f1=pm.output[i,'f1'], t.a = pm.output[i,'t.a'], C = pm.output[i,'C'],
delta= pm.output[i,'delta'], sigma = pm.output[i,'sigma'], rho = pm.output[i,'rho'],
optimal = optimal, control = list(temperature = temp))
}
### Best set of parameters found
V <- sapply(optim.power, `[[`, "par")
pm.output$power <- -sapply(optim.power, `[[`, "value")
pm.output$m0 <- V[1,]
if (optimal == 0) {
pm.output$m1 <- V[2,]
pm.output$k1 <- V[3,]
} else if (optimal == 1){
pm.output$m1 <- V[1,]
pm.output$k1 <- V[2,]
} else if (optimal == 2){
pm.output$m1 <- V[2,]
pm.output$k1 <- c(NA)
}
### Value of K0 using the best parameters found in the optimization process
if (optimal != 2) {
pm.output$k0 <- ((C - (pm.output$k1 * (f1 + (v1*pm.output$m1)))) / (f0 + (v0*pm.output$m0)))
} else if (optimal == 2) {
pm.output$k0 <- (C / ((f0 + f1) + (v0*pm.output$m0) + (v1*pm.output$m1)))
pm.output$k1 <- pm.output$k0
}
### Value of Cost using the best parameters found in the optimization process
pm.output$Cost <- pm.output$k0*(f0+ (v0*pm.output$m0)) + pm.output$k1*(f1+ (v1*pm.output$m1))
### Sort variables
pm.output.t <- pm.output[, c("iter.pm", "scenario", "delta", "sigma", "rho", "alpha", "k0.ic", "k1.ic", "m0.ic", "m1.ic", "C", "Cost", "v0", "v1", "f0", "f1", 'k0', "k1", 'm0', "m1", 'power', "K")]
### Value of Kt (K = k0 + k1)
pm.output.t$Kt <- (pm.output.t$k0 + pm.output.t$k1)
### Test K and Kt for exact equality
abs.dif.K <- abs(pm.output.t$'K' - pm.output.t$"Kt")
pm.output.t$same = ifelse((abs.dif.K< 0.01), "TRUE", "FALSE")
### Combine Outputs.t data frames
max.power <- as.data.frame(rbind(pm.output.t))
### Delete data from iteration with the normal distribution
rm ("pm.output", "optim.power", "V" )
### Power maximization - t-Distribution iterations ----------------------------------
repeat {
### Generate K values using the values from previous iteration
K = pm.output.t$Kt
### Delete data from previous iteration
rm ("pm.output.t")
### Generate variable with the number of iteration
iter.pm <-iter.pm+1
### Define the new data frame to store the outputs
pm.output.t<- as.data.frame(cbind(iter.pm, scenario, delta, sigma, rho, alpha, C, v0, v1, f0, f1, K))
pm.output.t <- as.data.frame(merge(initial.cond, pm.output.t, by="scenario"))
### one tail value "t.a" using t-Distribution
pm.output.t$df <- pm.output.t$K-q
pm.output.t$t.a <- qt((1-(alpha/2)),  pm.output.t$df, lower.tail = TRUE)
### Maximization of power
optim.power.t<- vector("list", nrow(pm.output.t))
for (i in 1:nrow(pm.output.t)) {
optim.power.t[[i]] <- GenSA(par = params[i,], fn=power.func.t.nA, lower=lower, upper=upper, v0=pm.output.t[i,'v0'], v1=pm.output.t[i,'v1'],
f0=pm.output.t[i,'f0'], f1=pm.output.t[i,'f1'], t.a=pm.output.t[i,'t.a'], df= pm.output.t[i,'df'],
C=pm.output.t[i,'C'], delta= pm.output.t[i,'delta'], sigma = pm.output.t[i,'sigma'], rho = pm.output.t[i,'rho'],
optimal = optimal, control = list(temperature = temp))
}
### Best set of parameters found
V.t <- sapply(optim.power.t, `[[`, "par")
pm.output.t$power <- -sapply(optim.power.t, `[[`, "value")
pm.output.t$m0 <- V.t[1,]
if (optimal == 0) {
pm.output.t$m1 <- V.t[2,]
pm.output.t$k1 <- V.t[3,]
} else if (optimal == 1){
pm.output.t$m1 <- V.t[1,]
pm.output.t$k1 <- V.t[2,]
} else if (optimal == 2){
pm.output.t$m1 <- V.t[2,]
pm.output.t$k1 <- c(NA)
}
### Value of K0 using the best parameters found in the optimization process
if (optimal != 2){
pm.output.t$k0 <- ((C - (pm.output.t$k1 * (f1 + (v1* pm.output.t$m1)))) /(f0 + (v0* pm.output.t$m0 )))
} else if (optimal == 2) {
pm.output.t$k0 <- (C / ((f0+f1) + (v0*pm.output.t$m0) + (v1*pm.output.t$m1)))
pm.output.t$k1 <- pm.output.t$k0
}
### Value of Cost using the best parameters found in the optimization process
pm.output.t$Cost <- pm.output.t$k0*(f0+ (v0*pm.output.t$m0)) + pm.output.t$k1*(f1+ (v1*pm.output.t$m1))
### Sort variables
pm.output.t <- pm.output.t[, c("iter.pm", "scenario", "delta", "sigma", "rho", "alpha", "m0.ic", "m1.ic", "k0.ic", "k1.ic", "C", "Cost", "v0", "v1", "f0", "f1", 'k0', "k1", 'm0', "m1", 'power', "K")]
### Value of Kt (K = k0 + k1)
pm.output.t$Kt <- (pm.output.t$k0 + pm.output.t$k1)
### Test K and Kt for exact equality
abs.dif.K <- abs(pm.output.t$'K' - pm.output.t$"Kt")
pm.output.t$same = ifelse((abs.dif.K< 0.01), "TRUE", "FALSE")
### Combine Outputs.t data frames
max.power <- as.data.frame(rbind(pm.output.t, max.power))
### Condition to break the iterations
brk = sum (ifelse (pm.output.t$"same"== "TRUE",1,0))
if (brk==length(scenario)) {
break
}
### Delete data from iteration with the normal distribution
rm ("optim.power.t", "V.t")
}
max.power$K=max.power$Kt
### Keep the best parameters found in the optimization process
results <- (max.power[1:nrow(pm.output.t), c("scenario", "delta", "sigma", "rho","C", "v0", "v1", "f0", "f1", 'k0', "k1", 'm0', "m1", 'power')])
### Delete data frames of initial conditions
rm ("pm.output.t", "V.t", "optim.power.t")
### Transposing objects
options( scipen = 24 )
optimum.power <- ((t(results)))
return (optimum.power)
}
maxpower.opt(delta = 0.25,
sigma = 1,
rho = 0.27,
alpha = 0.05,
C = c(148840.946392),
q = 1,
v0 = 9.36,
v1 = 9.36,
f0 = 189,
f1 = c(1000, 1776.4, 3000),
optimal.s = "CLUST-IND")
maxpower.opt(delta = 0.25,
sigma = 1,
rho = 0.27,
alpha = 0.05,
C = c(148840.946392),
q = 1,
v0 = 9.36,
v1 = 9.36,
f0 = 189,
f1 = c(1000, 1776.4, 3000),
optimal.s = "CLUST-IND",
output = "myresults")
getwd()
remove.packages("Optimal.sample")
library("Optimal.sample")
getwd()
setwd("/Users/nancydaza/OneDrive - University College London/Nancy_Marcos/Sample_Size_Nancy_Brendon_Marcos/Package")
setwd("./Optimal.sample")
library("Optimal.sample")
library(Optimal.sample)
maxpower.opt(delta = 0.25,
sigma = 1,
rho = 0.05,
alpha = 0.05,
C = c(815052.294, 974856.169, 1095876.675),
v0 = 150,
v1 = 2200,
f0 = 500,
f1 = 18000,
optimal.s = "CLUST-IND")
install.packages("devtools")
install.packages("usethis")
install.packages("pkgdown")
require(devtools,usethis,pkgdown)
install.packages("pkgdown")
require(devtools,usethis,pkgdown)
install.packages("devtools")
install.packages("usethis")
install.packages("pkgdown")
require(devtools)
require(usethis)
require(pkgdown)
use_readme_rmd()
use_news_md()
library(pkgdown)
library(usethis)
library("pkgdown")
usethis::use_pkgdown()
usethis::use_git()
yes
3
library(pkgdown)
library(usethis)
library("pkgdown")
usethis::use_pkgdown()
usethis::use_git()
usethis::use_github(protocol = "https")
pkgdown::build_site()
pkgdown::build_site()
devtools::install_github("brendonmcconnell/Optimal.sample")
pkgdown::build_site()
devtools::install_github("brendonmcconnell/Optimal.sample")
pkgdown::build_site()
pkgdown::build_site()
library("pkgdown")
usethis::use_pkgdown()
usethis::use_git()
usethis::use_github(protocol = "https")
devtools::install_github("brendonmcconnell/Optimal.sample")
pkgdown::build_site()
library("pkgdown")
library("pkgdown")
usethis::use_pkgdown()
usethis::use_git()
usethis::use_github(protocol = "https")
devtools::install_github("brendonmcconnell/Optimal.sample")
pkgdown::build_site()
library(pkgdown)
library("pkgdown")
usethis::use_pkgdown()
usethis::use_git()
devtools::install_github("brendonmcconnell/Optimal.sample")
usethis::use_github(protocol = "https")
usethis::use_pkgdown_github_pages()
pkgdown::build_site()
usethis::use_pkgdown_github_pages()
usethis::use_pkgdown_github_pages()
library(pkgdown)
library("pkgdown")
usethis::use_pkgdown()
usethis::use_git()
devtools::install_github("brendonmcconnell/Optimal.sample")
usethis::use_github(protocol = "https")
pkgdown::build_site()
